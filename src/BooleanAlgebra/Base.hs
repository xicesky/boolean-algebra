
-- "Standard" extensions
{-# LANGUAGE ScopedTypeVariables    #-}
{-# LANGUAGE InstanceSigs           #-}
{-# LANGUAGE FlexibleContexts       #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE DeriveFunctor          #-} 

-- Extensions for compdata usage
{-# LANGUAGE TemplateHaskell        #-}
{-# LANGUAGE TypeOperators          #-}

module BooleanAlgebra.Base where

{- Inspiration:
    https://tuprints.ulb.tu-darmstadt.de/2759/1/rkibria-dissertation-final-korrigiert1.pdf
    https://bartoszmilewski.com/2017/02/28/f-algebras/
    https://www-ps.informatik.uni-kiel.de/~sebf/projects/sat-solver/Control/Monad/Constraint/Boolean.lhs.html
    Recursion schemes: https://blog.sumtypeofway.com/archive.html
    Or as video: https://www.youtube.com/watch?v=Zw9KeP3OzpU
    Datatypes a la carte and followups:
        http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf
        http://www.cs.nott.ac.uk/~pszgmh/alacarte.pdf
-}

--import Data.Comp
import Data.Comp.Term
import Data.Comp.Ops
import Data.Comp.Sum (inject, split)
import Data.Comp.Algebra
    (   Alg, Coalg, RAlg, RCoalg
    ,   cata, ana, para, apo
    )

import Data.Comp.Derive
--import Data.Comp.Derive.Show
import Data.Comp.Show ()            -- for the Show instance
import Data.Comp.Equality ()        -- for the Eq instance

import BooleanAlgebra.THUtil

{-----------------------------------------------------------------------------}
-- Thinking

{-----------------------------------------------------------------------------}

-- Boolean Values
data BooleanValue e = BTrue | BFalse
    deriving (Show, Functor)

-- Variables
data BooleanVariable e = BVariable String   -- BIG YIKES! FIXME!
    deriving Functor

-- Boolean negation
data BooleanNot e = BNot e
    deriving Functor

-- Boolean conjunction
data BooleanAnd e = BAnd e e
    deriving Functor

-- Boolean disjunction
data BooleanOr e = BOr e e
    deriving Functor

{- Automatically generate everything we need. To see what's being
    generated by template haskell, run:
    stack ghci --ghci-options="-ddump-splices"

    We get smart constructors like:
        iBNot :: (BooleanNot :<: f) => Ctx h f a -> Ctx h f a
-}
$(deriveDefault
    [''BooleanValue
    ,''BooleanVariable
    ,''BooleanNot
    ,''BooleanAnd
    ,''BooleanOr
    ])

-- Shorthand names for some constructors
iBVar :: (BooleanVariable :<: f) => String -> Cxt h f a
iBVar = iBVariable

-- Base functor (called "Signature" in compdata)
type BooleanBaseF
    = BooleanValue
    :+: BooleanVariable
    :+: BooleanNot
    :+: BooleanAnd
    :+: BooleanOr

-- "Standard" boolean expressions
-- use ⊤, ⊥, ¬, ∧, ∨ and variables
type BooleanExpr = Term BooleanBaseF

-- Show instance for BooleanExpr already exists in Data.Comp.Show!

{-----------------------------------------------------------------------------}
-- "Pretty" printer
-- uses unicode symbols, but doesn't generate valid haskell expressions
-- Src: https://en.wikipedia.org/wiki/List_of_logic_symbols

{- TODO:
    Use https://hackage.haskell.org/package/prettyprinter-1.2.0.1#readme
-}

class Functor f => PrettyBool f where
    -- showsPrec for our pretty printer
    prettyPrintBoolAlg :: Alg f (Int -> ShowS)

-- Lift prettyPrintBoolAlg over sums of functors
$(deriveLiftSum [''PrettyBool])

instance PrettyBool BooleanValue where
    prettyPrintBoolAlg :: BooleanValue (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg BTrue _ = showString "⊤"
    prettyPrintBoolAlg BFalse _ = showString "⊥"

instance PrettyBool BooleanVariable where
    prettyPrintBoolAlg :: BooleanVariable (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg (BVariable s) _ = showString s

instance PrettyBool BooleanNot where
    prettyPrintBoolAlg :: BooleanNot (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg (BNot e) d = showParen (d > prec) $
        showString "¬" . e (prec+1)
        where prec = 10

instance PrettyBool BooleanAnd where
    prettyPrintBoolAlg :: BooleanAnd (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg (BAnd a b) d = showParen (d > prec) $
        a (prec+1) . showString "∧" . b (prec+1)
        where prec = 6

instance PrettyBool BooleanOr where
    prettyPrintBoolAlg :: BooleanOr (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg (BOr a b) d = showParen (d > prec) $
        a (prec+1) . showString "∨" . b (prec+1)
        where prec = 3

exampleExpr01 :: BooleanExpr
exampleExpr01 = (iBNot (iBVar "x" `iBAnd` iBVar "y")) `iBAnd` iBVar "z"

-- Class for other types, related to boolean expressions
-- (like BooleanExprSimp below)
class PrettyAlmostBool a where
    prettyPrintAB :: a -> Int -> ShowS

-- All our normal terms are pretty-printable
instance PrettyBool e => PrettyAlmostBool (Term e) where
    prettyPrintAB :: Term e -> Int -> ShowS
    prettyPrintAB = cata prettyPrintBoolAlg

-- Non-recursive terms can be pretty-printed for any param type
instance PrettyAlmostBool (BooleanValue a) where
    prettyPrintAB :: BooleanValue a -> Int -> ShowS
    prettyPrintAB = prettyPrintBoolAlg . fmap undefined

-- Non-recursive terms can be pretty-printed for any param type
instance PrettyAlmostBool (BooleanVariable a) where
    prettyPrintAB :: BooleanVariable a -> Int -> ShowS
    prettyPrintAB = prettyPrintBoolAlg . fmap undefined

prettyBool :: PrettyAlmostBool a => a -> String
prettyBool e = prettyPrintAB e 0 ""
