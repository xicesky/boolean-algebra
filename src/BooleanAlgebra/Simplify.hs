
-- "Standard" extensions
{-# LANGUAGE ScopedTypeVariables    #-}
{-# LANGUAGE InstanceSigs           #-}
{-# LANGUAGE FlexibleContexts       #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE DeriveFunctor          #-} 

-- Extensions for compdata usage
{-# LANGUAGE TemplateHaskell        #-}
{-# LANGUAGE TypeOperators          #-}

-- Considering advanced extensions
{-# LANGUAGE TypeFamilies           #-}

module BooleanAlgebra.Base where

{- Inspiration:
    https://tuprints.ulb.tu-darmstadt.de/2759/1/rkibria-dissertation-final-korrigiert1.pdf
    https://bartoszmilewski.com/2017/02/28/f-algebras/
    https://www-ps.informatik.uni-kiel.de/~sebf/projects/sat-solver/Control/Monad/Constraint/Boolean.lhs.html
    Recursion schemes: https://blog.sumtypeofway.com/archive.html
    Or as video: https://www.youtube.com/watch?v=Zw9KeP3OzpU
    Datatypes a la carte and followups:
        http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf
        http://www.cs.nott.ac.uk/~pszgmh/alacarte.pdf
-}

--import Data.Comp
import Data.Comp.Term
import Data.Comp.Ops
import Data.Comp.Sum (inject, split)
import Data.Comp.Algebra
    (   Alg, Coalg, RAlg, RCoalg
    ,   cata, ana, para, apo
    )

import Data.Comp.Derive
--import Data.Comp.Derive.Show
import Data.Comp.Show ()            -- for the Show instance
import Data.Comp.Equality ()        -- for the Eq instance

import Data.Bool (bool)
import Data.List (intersperse)
import Control.Monad (join)

import BooleanAlgebra.THUtil

{-----------------------------------------------------------------------------}
-- Thinking

{-----------------------------------------------------------------------------}

-- Boolean Values
data BooleanValue e = BTrue | BFalse
    deriving (Show, Functor)

-- Variables
data BooleanVariable e = BVariable String   -- BIG YIKES! FIXME!
    deriving Functor

-- Boolean negation
data BooleanNot e = BNot e
    deriving Functor

-- Boolean conjunction
data BooleanAnd e = BAnd e e
    deriving Functor

-- Boolean disjunction
data BooleanOr e = BOr e e
    deriving Functor

{- Automatically generate everything we need. To see what's being
    generated by template haskell, run:
    stack ghci --ghci-options="-ddump-splices"

    We get smart constructors like:
        iBNot :: (BooleanNot :<: f) => Ctx h f a -> Ctx h f a
-}
$(deriveDefault
    [''BooleanValue
    ,''BooleanVariable
    ,''BooleanNot
    ,''BooleanAnd
    ,''BooleanOr
    ])

-- Shorthand names for some constructors
iBVar :: (BooleanVariable :<: f) => String -> Cxt h f a
iBVar = iBVariable

-- Base functor (called "Signature" in compdata)
type BooleanBaseF
    = BooleanValue
    :+: BooleanVariable
    :+: BooleanNot
    :+: BooleanAnd
    :+: BooleanOr

-- "Standard" boolean expressions
-- use ⊤, ⊥, ¬, ∧, ∨ and variables
type BooleanExpr = Term BooleanBaseF

-- Show instance for BooleanExpr already exists in Data.Comp.Show!

{-----------------------------------------------------------------------------}
-- "Pretty" printer
-- uses unicode symbols, but doesn't generate valid haskell expressions
-- Src: https://en.wikipedia.org/wiki/List_of_logic_symbols

{- TODO:
    Use https://hackage.haskell.org/package/prettyprinter-1.2.0.1#readme
-}

class Functor f => PrettyBool f where
    -- showsPrec for our pretty printer
    prettyPrintBoolAlg :: Alg f (Int -> ShowS)

-- Lift prettyPrintBoolAlg over sums of functors
$(deriveLiftSum [''PrettyBool])

instance PrettyBool BooleanValue where
    prettyPrintBoolAlg :: BooleanValue (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg BTrue _ = showString "⊤"
    prettyPrintBoolAlg BFalse _ = showString "⊥"

instance PrettyBool BooleanVariable where
    prettyPrintBoolAlg :: BooleanVariable (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg (BVariable s) _ = showString s

instance PrettyBool BooleanNot where
    prettyPrintBoolAlg :: BooleanNot (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg (BNot e) d = showParen (d > prec) $
        showString "¬" . e (prec+1)
        where prec = 10

instance PrettyBool BooleanAnd where
    prettyPrintBoolAlg :: BooleanAnd (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg (BAnd a b) d = showParen (d > prec) $
        a (prec+1) . showString "∧" . b (prec+1)
        where prec = 6

instance PrettyBool BooleanOr where
    prettyPrintBoolAlg :: BooleanOr (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg (BOr a b) d = showParen (d > prec) $
        a (prec+1) . showString "∨" . b (prec+1)
        where prec = 3

exampleExpr01 :: BooleanExpr
exampleExpr01 = (iBNot (iBVar "x" `iBAnd` iBVar "y")) `iBAnd` iBVar "z"

-- Class for other types, related to boolean expressions
-- (like BooleanExprSimp below)
class PrettyAlmostBool a where
    prettyPrintAB :: a -> Int -> ShowS

-- All our normal terms are pretty-printable
instance PrettyBool e => PrettyAlmostBool (Term e) where
    prettyPrintAB :: Term e -> Int -> ShowS
    prettyPrintAB = cata prettyPrintBoolAlg

-- Non-recursive terms can be pretty-printed for any param type
instance PrettyAlmostBool (BooleanValue a) where
    prettyPrintAB :: BooleanValue a -> Int -> ShowS
    prettyPrintAB = prettyPrintBoolAlg . fmap undefined

-- Non-recursive terms can be pretty-printed for any param type
instance PrettyAlmostBool (BooleanVariable a) where
    prettyPrintAB :: BooleanVariable a -> Int -> ShowS
    prettyPrintAB = prettyPrintBoolAlg . fmap undefined

prettyBool :: PrettyAlmostBool a => a -> String
prettyBool e = prettyPrintAB e 0 ""

{-----------------------------------------------------------------------------}
-- Simplifier   (Step 1 of toCNF)

-- BooleanExprF without BooleanValue
type BooleanExprSimpF
    =   BooleanVariable
    :+: BooleanNot
    :+: BooleanAnd
    :+: BooleanOr

-- Simplified boolean expressions are either just "true" or "false"
-- or terms without any boolean values
type BooleanExprSimp = Either (BooleanValue ()) (Term BooleanExprSimpF)

-- Pretty-printable
-- actually all instances with "Either a b" are pretty-printable, if both a and b are.
-- We see the "Either" instance as "untagged" because we assume that a and b are disjunct.
instance (PrettyAlmostBool a, PrettyAlmostBool b) => PrettyAlmostBool (Either a b) where
    prettyPrintAB :: Either a b -> Int -> ShowS
    prettyPrintAB (Left v) = prettyPrintAB v
    prettyPrintAB (Right e) = prettyPrintAB e

{- simpBool pushes boolean values outwards
    and mostly eliminates them.
    If any values BTrue/BFalse remain, they are the
    topmost expression (i.e. if the whole expression is True/False).
-}
class Functor f => SimpBool f where
    simpBool :: Alg f BooleanExprSimp

-- Lift simpBool over sums of functors
$(deriveLiftSum [''SimpBool])

instance SimpBool BooleanValue where
    simpBool :: BooleanValue BooleanExprSimp -> BooleanExprSimp
    simpBool (BTrue)    = Left BTrue
    simpBool (BFalse)   = Left BFalse

instance SimpBool BooleanVariable where
    simpBool :: BooleanVariable BooleanExprSimp -> BooleanExprSimp
    simpBool = Right . inject . fmap undefined
    -- simpBool (BVariable v)  = Right $ iBVar v

instance SimpBool BooleanNot where
    simpBool :: BooleanNot BooleanExprSimp -> BooleanExprSimp
    simpBool (BNot (Left BTrue))    = Left BFalse
    simpBool (BNot (Left BFalse))   = Left BTrue
    simpBool (BNot (Right other))   = Right $ iBNot other

instance SimpBool BooleanAnd where
    simpBool :: BooleanAnd BooleanExprSimp -> BooleanExprSimp
    simpBool (BAnd (Left BTrue) e)  = e
    simpBool (BAnd (Left BFalse) e) = Left BFalse
    simpBool (BAnd e (Left BTrue))  = e
    simpBool (BAnd e (Left BFalse)) = Left BFalse
    simpBool (BAnd (Right a) (Right b)) = Right $ iBAnd a b

instance SimpBool BooleanOr where
    simpBool :: BooleanOr BooleanExprSimp -> BooleanExprSimp
    simpBool (BOr (Left BTrue) e)   = Left BTrue
    simpBool (BOr (Left BFalse) e)  = e
    simpBool (BOr e (Left BTrue))   = Left BTrue
    simpBool (BOr e (Left BFalse))  = e
    simpBool (BOr (Right a) (Right b)) = Right $ iBOr a b

simplifyPrimitive :: BooleanExpr -> BooleanExprSimp
simplifyPrimitive = cata simpBool

-- It is very annoying to have to deal with the "Either" part
-- but this is a hack.
-- If you can, use fmap instead:
--      fmap :: (a -> b) -> Either x a -> Either x b
hackSimp :: BooleanExprSimp -> Term BooleanExprSimpF
hackSimp (Right expr) = expr
hackSimp otherwise = error $ "hackSimp() failed, expression is " ++ show otherwise

exampleExpr02 :: BooleanExpr
exampleExpr02 = iBNot ((iBNot iBTrue) `iBAnd` (iBNot iBFalse))

{-----------------------------------------------------------------------------}
-- Boolean literals     (Step 2 of toCNF)
-- Literal = Variable + optional Negation

data BooleanLit e = BooleanLit Bool String
    deriving (Show, Eq, Functor)
    {- NOTE: For this construction deriveDefault apparently
    can't work out Show and Eq -}

$(deriveDefault [''BooleanLit] )

-- Shorthands
iPos :: (BooleanLit :<: f) => String -> Cxt h f a
iPos = iBooleanLit True

iNeg :: (BooleanLit :<: f) => String -> Cxt h f a
iNeg = iBooleanLit False

-- Let's also pretty-print it
instance PrettyBool BooleanLit where
    prettyPrintBoolAlg :: BooleanLit (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg (BooleanLit positive s) _
        = (bool (showString "¬") id positive) . (showString s)

-- Non-recursive terms can be pretty-printed for any param type
instance PrettyAlmostBool (BooleanLit a) where
    prettyPrintAB :: BooleanLit a -> Int -> ShowS
    prettyPrintAB = prettyPrintBoolAlg . fmap undefined

-- BooleanExpr without BooleanValue, BooleanVariable, BooleanNot
--  but using BooleanLit
type BooleanExprLitF
    =   BooleanLit
    :+: BooleanAnd
    :+: BooleanOr

type BooleanExprLit = Term BooleanExprLitF

-- pushNeg eliminates negations by pushing them inwards
-- and turning variables into literals
class Functor f => PushNeg f where
    pushNeg :: Alg f (Bool -> BooleanExprLit)

-- Lift pushNeg over sums of functors
$(deriveLiftSum [''PushNeg])

instance PushNeg BooleanVariable where
    pushNeg :: BooleanVariable (Bool -> BooleanExprLit) -> (Bool -> BooleanExprLit)
    pushNeg (BVariable s) positive = iBooleanLit positive s

instance PushNeg BooleanNot where
    pushNeg :: BooleanNot (Bool -> BooleanExprLit) -> (Bool -> BooleanExprLit)
    pushNeg (BNot lit) positive = lit (not positive)

instance PushNeg BooleanAnd where
    pushNeg :: BooleanAnd (Bool -> BooleanExprLit) -> (Bool -> BooleanExprLit)
    pushNeg (BAnd a b) False = iBOr (a False) (b False)
    pushNeg (BAnd a b) True  = iBAnd (a True) (b True)

instance PushNeg BooleanOr where
    pushNeg :: BooleanOr (Bool -> BooleanExprLit) -> (Bool -> BooleanExprLit)
    pushNeg (BOr a b) False = iBAnd (a False) (b False)
    pushNeg (BOr a b) True  = iBOr (a True) (b True)

-- Idea: PushNeg can operate on extended operation (see below)

pushNegations :: Term BooleanExprSimpF -> BooleanExprLit
pushNegations e = cata pushNeg e True

-- We usually want to apply it to BooleanExprSimp directly
-- usage e.g.: prettyBool $ pushNegations' $ simplifyPrimitive $ exampleExpr05
pushNegations' :: BooleanExprSimp -> Either (BooleanValue ()) BooleanExprLit
pushNegations' = fmap pushNegations

{- TODO:
Maybe pushNegations can be decomposed into two functions
    mkLit :: Bool -> Variable -> Literal
    pushNegations :: (Bool -> Variable -> a) -> Term (...) -> Term (... :+: a)
So we can get the function
     pushNegForm :: BooleanExprSimp -> BooleanExprSimp
for free

TODO: Function to turn literals back into BooleanVariable :+: BooleanNot
-}

{-----------------------------------------------------------------------------}
-- Aggregator   (Helper)

{- 
Repeated conjunctions are aggregated into lists (using associativity)
    a ∧ b ∧ c ∧ d = Conj [a,b,c,d]
    Conj [] = True

Repeated disjunctions are aggregated into lists (using associativity)
    a ∨ b ∨ c ∨ d = Disj [a,b,c,d]
    Disj [] = False
-}

{- BooleanCD: Conjunction over Disjunctions
    BooleanCD [[a,b],[c,d]] ≅ (a ∨ b) ∧ (c ∨ d)
-}
data BooleanCD e = BooleanCD [[e]]
    --deriving Functor
    deriving (Show, Eq, Functor)

{- TODO: Fix bugs in compdata

Bug #1:
    show-ing terms of BooleanCD is wrong and puts quotes where none belong:
        putStrLn $ show exampleExpr03
        (BooleanCD [["(BooleanLit True \"a\")","(BooleanLit False \"b\")"],["(BooleanLit False \"c\")","(BooleanLit True \"d\")"]])
    
    Data.Comp.Derive.Show handles arguments this way:
        mkShow :: (Bool, ExpQ) -> ExpQ
        mkShow (isFArg, var)
            | isFArg = var
            | otherwise = [| show $var |]
    Apparently [[e]] is not a functor argument - this can lead to other bugs!

    This one will be hard to get right, but should accept nested functors:
        data Meh e = Meh e          deriving Functor
        data Muh e = Muh (Meh e)    deriving Functor

Bug #2:
    compdata should use showsPrec instead of show
    1. Performance (maybe not that relevant, ghc rewrites a lot of that stuff)
    2. Precedence is important, don't put parens everywhere

-}

$(deriveNoShow [''BooleanCD])

-- Utility function: Concatenate a list of ShowS using a seperator
ccShowList :: String -> String -> String -> [ShowS] -> ShowS
ccShowList begin sep end list = let
    sList = foldr (.) id $ intersperse (showString sep) list
    in showString begin . sList . showString end

-- Copied over from Data.Comp.Derive.Show
showCon :: String -> [String] -> String
showCon con [] = con
showCon con args = "(" ++ con ++ " " ++ unwords args ++ ")"

-- Custom instance of ShowF - workaround for a bug in compdata
instance ShowF BooleanCD where
    showF (BooleanCD xs) = let
        ccList :: [ShowS] -> ShowS
        ccList = ccShowList "[" ", " "]"
        strCDs :: ShowS
        strCDs = ccList . fmap (ccList . fmap (++)) $ xs
        in (showCon "BooleanCD") [strCDs ""]

{- Utility function:
Concatenate lists of precedence-dependent arguments with an operator
-}
ccListOp :: (Int, String) -> (Int -> ShowS) -> [Int -> ShowS] -> Int -> ShowS
ccListOp _          empty []    = empty
ccListOp _          _     [e]   = e
ccListOp (prec, op) _     es    = \d -> let
    listOfShowS :: [ShowS]
    listOfShowS = fmap ($ prec+1) es
    in showParen (d > prec) $ ccShowList "" op "" listOfShowS

-- Pretty-printer for BooleanCD
instance PrettyBool BooleanCD where
    prettyPrintBoolAlg :: BooleanCD (Int -> ShowS) -> Int -> ShowS
    prettyPrintBoolAlg (BooleanCD cds) d
        = showCDs cds d where
            showDisjs :: [Int -> ShowS] -> Int -> ShowS
            showDisjs = ccListOp (3, "∨") empty where
                empty = prettyPrintAB BFalse

            showConjs :: [Int -> ShowS] -> Int -> ShowS
            showConjs = ccListOp (6, "∧") empty where
                empty = prettyPrintAB BTrue

            showCDs :: [[Int -> ShowS]] -> Int -> ShowS
            showCDs = showConjs . fmap showDisjs

-- BooleanExprLit where BooleanCD replaces (BooleanAnd, BooleanOr)
type BooleanExprCDLitF
    =   BooleanLit
    :+: BooleanCD

type BooleanExprCDLit = Term BooleanExprCDLitF

-- unCDLit gives us a guaranteed CD term
unCDLit :: BooleanExprCDLit -> BooleanCD BooleanExprCDLit
unCDLit = split unCD unLit where
    unCD :: BooleanCD BooleanExprCDLit -> BooleanCD BooleanExprCDLit
    unCD = id
    unLit :: BooleanLit BooleanExprCDLit -> BooleanCD BooleanExprCDLit
    unLit = BooleanCD . pure . pure . inject

-- aggregateCD aggregates into conjunctions over disjunctions
class Functor f => AggregateCD f where
    aggregateCD :: Alg f BooleanExprCDLit

-- Lift aggregateCD over sums of functors
$(deriveLiftSum [''AggregateCD])

instance AggregateCD BooleanValue where
    aggregateCD :: BooleanValue BooleanExprCDLit -> BooleanExprCDLit
    aggregateCD BTrue = iBooleanCD []       -- Conjunction of 0 terms
    aggregateCD BFalse = iBooleanCD [[]]    -- Disjunction of 0 terms

instance AggregateCD BooleanLit where
    aggregateCD :: BooleanLit BooleanExprCDLit -> BooleanExprCDLit
    aggregateCD lit = inject lit

instance AggregateCD BooleanAnd where
    aggregateCD :: BooleanAnd BooleanExprCDLit -> BooleanExprCDLit
    aggregateCD (BAnd cda cdb) = iBooleanCD $ cdas ++ cdbs where
        BooleanCD cdas = unCDLit cda
        BooleanCD cdbs = unCDLit cdb

instance AggregateCD BooleanOr where
    aggregateCD :: BooleanOr BooleanExprCDLit -> BooleanExprCDLit
    aggregateCD (BOr cda cdb) = let
        BooleanCD cdas = unCDLit cda
        BooleanCD cdbs = unCDLit cdb
        in case (cdas, cdbs) of
            -- Both are just disjunctions
            ([disja], [disjb]) -> iBooleanCD [disja ++ disjb]
            -- All other cases require an outer CD term
            _ -> iBooleanCD [[cda, cdb]]

-- This is the actual aggregation function, using a catamorphism
aggregateConjDisj :: BooleanExprLit -> BooleanExprCDLit
aggregateConjDisj e = cata aggregateCD e

-- Tiny helper for our old "Either" problem
aggregateConjDisj' :: Either (BooleanValue ()) BooleanExprLit -> BooleanExprCDLit
aggregateConjDisj' (Left BTrue) = iBooleanCD []
aggregateConjDisj' (Left BFalse) = iBooleanCD [[]]  -- TODO: this should be a function, also BVal -> Boolean
aggregateConjDisj' (Right e) = aggregateConjDisj e

-- exampleExprCD :: BooleanExprCDLit
-- exampleExprCD = iBooleanCD [ [ iPos "a", iNeg "b" ], [ iNeg "c", iPos "d" ] ]

-- This will result in a single (non-nested) CD
exampleExpr03 :: BooleanExpr
exampleExpr03 = (iBVar "a" `iBOr` iBVar "b") `iBAnd` (iBVar "c" `iBOr` iBVar "d")

-- This will result in nested CDs, bc. of disjunctions over conjunctions
exampleExpr04 :: BooleanExpr
exampleExpr04 = (iBVar "a" `iBAnd` iBVar "b") `iBOr` (iBVar "c" `iBAnd` iBVar "d")

{-----------------------------------------------------------------------------}
-- Distributor  (Step 3 of toCNF)
-- Distributes disjunctions over conjunctions:
--      a ∨ (b ∧ c) = (a ∨ b) ∧ (a ∨ c)

type CNF = BooleanCD (BooleanLit ())

-- Shorthands
lPos :: String -> BooleanLit a
lPos = BooleanLit True

lNeg :: String -> BooleanLit a
lNeg = BooleanLit False

-- Pretty-printer for CNF
-- Idea: Maybe print each disjunktion on a seperate line
instance PrettyAlmostBool a => PrettyAlmostBool (BooleanCD a) where
    prettyPrintAB :: BooleanCD a -> Int -> ShowS
    prettyPrintAB = prettyPrintBoolAlg . fmap prettyPrintAB where

-- a ∨ (x0 ∧ x1 ∧ ...) = (a ∨ x0) ∧ (a ∨ x1) ∧ ...
distrLit :: BooleanLit a -> [[BooleanLit a]] -> [[BooleanLit a]]
distrLit a xs = fmap (a :) xs

-- (a0 ∨ ...) ∨ (x0 ∧ ...) = (a0 ∨ ... ∨ x0) ∧ ...
distrDisj :: [BooleanLit a] -> [[BooleanLit a]] -> [[BooleanLit a]]
distrDisj as xs = fmap (as ++) xs

-- (as0 ∧ as1 ∧ ...) ∨ (x0 ∧ ...) = (as0 ∨ (x0 ...)) ∧ (as1 ∨ (x0 ...)) ∧ ...
distrConj :: [[BooleanLit a]] -> [[BooleanLit a]] -> [[BooleanLit a]]
distrConj ass xs = join $ fmap (\as -> distrDisj as xs) ass

-- Disjunction of two CNFs
distrCNF :: CNF -> CNF -> CNF
distrCNF (BooleanCD a) (BooleanCD x) = BooleanCD $ distrConj a x

-- Conjunction of two CNFs
joinCNF :: CNF -> CNF -> CNF
joinCNF (BooleanCD a) (BooleanCD x) = BooleanCD $ a ++ x

-- Distribute Disjunctions over Conjunctions (limited to BooleanCD)
class Functor f => DistributeDoC f where
    distributeDoC :: Alg f CNF

-- Lift aggregateCD over sums of functors
$(deriveLiftSum [''DistributeDoC])

instance DistributeDoC BooleanLit where
    distributeDoC :: BooleanLit CNF -> CNF
    distributeDoC lit = BooleanCD [[fmap undefined lit]]

instance DistributeDoC BooleanCD where
    distributeDoC :: BooleanCD CNF -> CNF
    distributeDoC (BooleanCD conjs) = foldr1 joinCNF $ fmap distr conjs where
        distr :: [CNF] -> CNF
        distr (x:[]) = x
        distr (x:xs) = distr $ fmap (distrCNF x) xs

distributeToCNF :: BooleanExprCDLit -> CNF
distributeToCNF = cata distributeDoC

exampleCNF :: CNF
exampleCNF = BooleanCD [ [ lPos "a", lNeg "b" ], [ lNeg "c", lPos "d" ] ]

{-----------------------------------------------------------------------------}
-- Basic conversion to CNF
-- doesn't add any variables

toCNF :: BooleanExpr -> CNF
toCNF = distributeToCNF . aggregateConjDisj' . pushNegations' . simplifyPrimitive

-- Test it on this, e.g.: pushOr $ pushNeg $ exampleExpr05
exampleExpr05 :: BooleanExpr
exampleExpr05 = iBNot $ ((iBNot $ iBVar "a") `iBOr` iBVar "b") `iBAnd` (iBNot $ iBVar "c" `iBAnd` iBVar "d")
